##################################################################################################
from fastapi import FastAPI, HTTPException, Depends, Request
from pydantic import BaseModel, Field, validator
from typing import Optional
import uvicorn
import subprocess
from sqlalchemy import create_engine, text, event
from sqlalchemy.orm import Session
from sqlalchemy.exc import OperationalError, DisconnectionError
from database.db_test.db import SessionLocal, engine, Base, get_db  # Updated import
from database.db_test import models
import os
from .openai_eval import *
from database.connectors.s3 import S3Connector
from utils.utility import get_month_year_from_datetime, get_call_duration, current_time, strip_data_func
from datetime import datetime
from urllib.parse import unquote
from .extractor_config import *
# Update this import to use the new function
from database.db_test.db import get_call_by_room  # This now uses SQLAlchemy ORM with retry logic
from database.db_test.database_config import get_db_type  # Add this import

from .prompts_for_eval.prompt import prompt, prompt2
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, JSONResponse, Response
from io import BytesIO
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
import httpx
import asyncio
import json
import logging

# Load environment variables
load_dotenv(dotenv_path="/app/.env.local")

# Create tables in the database
Base.metadata.create_all(bind=engine)

# Get database type for any database-specific logic
DB_TYPE = get_db_type()

# Set up logging
logger = logging.getLogger("api")

app = FastAPI(title="LiveKit Dispatch API") 
open_ai_api = os.getenv("OPENAI_API_KEY")
BASE_URL = "http://sbi.vaaniresearch.com:1244"
client_name = os.getenv("CLIENT_NAME")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


def get_database():
    """Enhanced database dependency with error handling"""
    db = SessionLocal()
    try:
        # Test the connection
        db.execute(text("SELECT 1"))
        print("Database connection established successfully.")
        yield db
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in get_database: {e}")
        db.rollback()
        db.close()
        # Create a new session and try again
        db = SessionLocal()
        try:
            db.execute(text("SELECT 1"))
            yield db
        except Exception as retry_error:
            logger.error(f"Failed to establish database connection: {retry_error}")
            db.rollback()
            db.close()
            raise HTTPException(status_code=503, detail="Database unavailable")
    except Exception as e:
        logger.error(f"Database error in get_database: {e}")
        db.rollback()
        db.close()
        raise HTTPException(status_code=500, detail="Database error")
    finally:
        db.close()


class UserCreate(BaseModel):
    username: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class DispatchRequest(BaseModel):
    user_id: str
    name: str = Field(..., description="Customer name")
    contact_number: str = Field(..., description="Contact number with country code")
    agent_name: str = Field(..., description="Agent Name")
    
    @validator('contact_number')
    def validate_contact_number(cls, v):
        # Ensure contact number starts with "+"
        if not v.startswith('+'):
            v = '+' + v
        return v

class DispatchResponse(BaseModel):
    success: bool
    message: Optional[str] = "Command processed"  # Default value makes it optional
    output: Optional[str] = None
    error: Optional[str] = None

class ModelCreate(BaseModel):
    model_id: str
    model_name: str
    client_name: str

class ModelUpdate(BaseModel):
    model_name: str | None = None
    client_name: str | None = None

    class Config:
        orm_mode = True

class CallUpdate(BaseModel):
    call_id: str
    name: Optional[str] = None
    call_from: Optional[str] = None
    call_to: Optional[str] = None
    call_type: Optional[str] = None
    call_started_at: Optional[datetime] = None
    call_duration: Optional[float] = None  # in seconds
    call_summary: Optional[str] = None  # Made explicitly nullable
    call_transcription: Optional[str] = None  # Made explicitly nullable
    call_recording_url: Optional[str] = None  # Made explicitly nullable
    call_conversation_quality: Optional[dict] = None  # Made explicitly nullable
    model_id: Optional[str] = None  # FIXED: Changed from int to str to match schema
    call_completed: Optional[bool] = False
    user_id: Optional[int] = None  # Made nullable
    call_entity: Optional[dict] = None  # Made explicitly nullable

class FeedbackCreate(BaseModel):
    user_id: int
    feedback_text: str
    felt_natural: Optional[int] = None  # FIXED: Changed from felt_neutral
    response_speed: Optional[int] = None
    interruptions: Optional[int] = None

## User APIs with connection resilience
@app.post("/api/users/")
def create_user(user: UserCreate, db: Session = Depends(get_database)):
    try:
        new_user = models.User(**user.dict())
        db.add(new_user)
        db.commit()
        db.refresh(new_user)
        return new_user
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in create_user: {e}")
        db.rollback()
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating user: {e}")
        raise HTTPException(status_code=500, detail=f"Error creating user: {str(e)}")

@app.post("/api/login/")
def login(user: UserLogin, db: Session = Depends(get_database)):
    try:
        user_data = db.query(models.User).filter(
            models.User.username == user.username, 
            models.User.password == user.password
        ).first()
        if not user_data:
            raise HTTPException(status_code=401, detail="Invalid credentials")
        return {"message": "Login successful", "user_id": user_data.id, "user_name": user_data.username}
    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in login: {e}")
        db.rollback()
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        db.rollback()
        logger.error(f"Error during login: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

#Make call APIs
@app.post("/api/trigger-call/", response_model=DispatchResponse)
async def create_dispatch(fastapi_request: Request, db: Session = Depends(get_database)):
    """
    Create a LiveKit dispatch with the provided customer details
    
    - **name**: Customer name
    - **contact_number**: Contact number with country code
    - **agent_name**: Agent name
    """
    try:
        request_body = await fastapi_request.json()
        print(f"request_body: {request_body}")

        from utils.call import run_livekit_dispatch
        
        # FIXED: Updated to use string model_id instead of int
        model = db.query(models.Model).filter(models.Model.model_id == request_body['agent_id']).first()
        if not model:
            raise HTTPException(status_code=404, detail=f"Model with ID {request_body['agent_id']} not found")
            
        metadata_ = {
            "name": request_body['name'],
            "phone": request_body['contact_number'],
            "agent_name": model.model_name,
        }
        
        result = run_livekit_dispatch(
            metadata=metadata_,
            contact_number=request_body['contact_number'],
            agent_name=model.model_name,
        )
        if not result["success"]:
            raise HTTPException(status_code=500, detail=result["error"])
        
        # Parse the result output to extract the room ID
        import re
        
        # Extract room ID
        room_match = re.search(r'room:"(.*?)"', result["output"])
        room_id = room_match.group(1) if room_match else None
        
        # Create a new call record with proper field mapping
        new_call = models.Call(
            user_id=int(request_body['user_id']),
            call_id=room_id,
            name=request_body['name'],
            call_to=request_body['contact_number'],
            call_from="+12512202179",
            call_type="Outbound",
            model_id=model.model_id,  # This is now string type
            call_transcription=f"{BASE_URL}/api/transcript/{room_id}",
            call_recording_url=f"{BASE_URL}/api/stream/{room_id}",
            call_duration=0,  # FIXED: Removed call_completed field, using call_duration
        )
        
        # Add to database
        db.add(new_call)
        db.commit()
        db.refresh(new_call)
        
        # Add call ID to the response
        result["call_db_id"] = new_call.id
        
        return result
        
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in create_dispatch: {e}")
        db.rollback()
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating dispatch: {e}")
        raise HTTPException(status_code=500, detail=f"Error creating dispatch: {str(e)}")

#Data APIs
@app.get("/api/call-history/{user_id}/{client_name}")
async def get_call_history(user_id: int, client_name: str, db: Session = Depends(get_database)):
    try:
        import time
        start_time_total = time.time()
        call_history = db.query(models.Call).filter(models.Call.user_id == user_id).all()
        
        curated_response = []
        for call in call_history:
            updated_call = {}
            conversation_id = call.call_id
            
            start_time = time.time()
            call_data_row = get_call_by_room(conversation_id)
            
            if call_data_row is None:  # This is to tackle the old data.
                # FIXED: Use call_status instead of call_completed
                if call.call_status == "ended":
                    call_status = "ended"
                else:
                    call_status = "Ongoing"
                
                updated_call['Name'] = {'name': call.name}
                updated_call['Start_time'] = call.call_started_at
                updated_call['End_time'] = call.call_ended_at if call.call_ended_at else call.call_started_at
                updated_call['recording_api'] = call.call_recording_url
                updated_call['call_details'] = f"{BASE_URL}/api/call_details/{client_name}/{user_id}/{call.call_id}"
                updated_call['call_type'] = call.call_type
                updated_call['call_status'] = call_status
                updated_call['from_number'] = call.call_from
                updated_call['to_number'] = call.call_to
                updated_call['direction'] = call.call_type
                updated_call['duration_ms'] = call.call_duration

            else:
                # Get the duration of the call in ms
                if call_data_row.get('ended_at') is None and call_data_row.get('status') in ["started", "Call rejected", "Not picked"]:
                    duration = 0
                else:
                    started_at_str = call_data_row.get('started_at')
                    ended_at_str = call_data_row.get('ended_at')

                    if started_at_str and ended_at_str:
                        started_at = datetime.fromisoformat(started_at_str)
                        ended_at = datetime.fromisoformat(ended_at_str)
                        duration = (ended_at - started_at).total_seconds() * 1000  # duration in milliseconds
                    else:
                        duration = 0

                updated_call['Name'] = {'name': call.name}
                updated_call['Start_time'] = call_data_row.get('started_at')
                updated_call['End_time'] = call_data_row.get('ended_at', call.call_started_at)
                updated_call['recording_api'] = call.call_recording_url
                updated_call['call_details'] = f"{BASE_URL}/api/call_details/{client_name}/{user_id}/{call.call_id}"
                updated_call['call_type'] = call.call_type
                updated_call['call_status'] = call_data_row.get('status', 'Unknown')
                updated_call['from_number'] = call.call_from
                updated_call['to_number'] = call.call_to
                updated_call['direction'] = call.call_type
                updated_call['duration_ms'] = duration
        
            curated_response.append(updated_call)

        reversed_list = curated_response[::-1]
        time_taken_total = time.time() - start_time_total
        print(f"Total time taken to fetch call history: {time_taken_total} seconds")
        return reversed_list
        
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in get_call_history: {e}")
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        logger.error(f"Error fetching call history: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching call history: {str(e)}")

@app.get("/api/transcript/{call_id}")
async def get_transcript(call_id: str, db: Session = Depends(get_database)):
    """
    Retrieve the transcript for a call
    """
    try:
        # Find the call
        call = db.query(models.Call).filter(models.Call.call_id == call_id).first()
        if not call:
            raise HTTPException(status_code=404, detail=f"Call with ID {call_id} not found")
        
        status_code = 200
        
        s3_bucket = os.getenv("AWS_BUCKET")
        s3_connector = S3Connector(s3_bucket)
        year, month = get_month_year_from_datetime(str(call.call_started_at))
        transcript_path = f"transcripts/{client_name}/{year}/{month}/{call_id}.txt"
            
        # Get the transcript asynchronously
        try:
            result_transcript = await s3_connector.fetch_file_async(transcript_path)
            transcript_bytes = result_transcript if result_transcript is not None else None
            
            if transcript_bytes is None:
                transcript_content = "Transcript not found in S3"
                status_code = 404
                call_duration = 0
            
            # Convert bytes to string
            else:
                transcript_cont_ = transcript_bytes.decode('utf-8')
                if transcript_cont_ == "":
                    transcript_content = "Transcript is empty"
                    call_duration = 0
                else:
                    call_data_row = get_call_by_room(call_id)
                    if call_data_row is None:
                        call_duration = get_call_duration(transcript_cont_)
                    else:
                        if call_data_row.get('ended_at') is None and call_data_row.get('status') in ["started", "Call rejected", "Not picked"]:
                            duration = 0
                        else:
                            started_at_str = call_data_row.get('started_at')
                            ended_at_str = call_data_row.get('ended_at')

                            if started_at_str and ended_at_str:
                                started_at = datetime.fromisoformat(started_at_str)
                                ended_at = datetime.fromisoformat(ended_at_str)
                                duration = (ended_at - started_at).total_seconds() * 1000  # duration in milliseconds
                            else:
                                duration = 0

                    call_duration = duration
                    transcript_content = strip_data_func(transcript_cont_)
            
            # Update the call record with the transcript
            call.call_transcription = transcript_content
            call.call_duration = call_duration
            db.commit()
            db.refresh(call)

            return {"transcript": transcript_content, "status_code": status_code, "function": "get_transcript"}
    
        except Exception as e:
            return {"transcript": "Error fetching transcript", "status_code": 500, "function": "get_transcript", "error": str(e)}

    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in get_transcript: {e}")
        return {"transcript": "Database connection issue", "status_code": 503, "function": "get_transcript", "error": str(e)}
    except Exception as e:
        return {"transcript": "Error retrieving transcript", "status_code": 500, "function": "get_transcript(exception)", "error": str(e)}

@app.get("/api/stream/{call_id}")
async def stream_audio(call_id: str, db: Session = Depends(get_database)):
    """
    Stream audio file from S3
    """
    try:
        # Find the call
        call = db.query(models.Call).filter(models.Call.call_id == call_id).first()
        if not call:
            raise HTTPException(status_code=404, detail=f"Call with ID {call_id} not found")
        
        # Construct the recording path based on your pattern
        recording_path = f"{call_id}.mp3"
        
        # Get S3 bucket
        s3_bucket = os.getenv("AWS_BUCKET")
        s3_connector = S3Connector(s3_bucket)
        
        # Get the audio file asynchronously
        path_of_recording = f"mp3/{recording_path}"
        audio_bytes = await s3_connector.fetch_file_async(path_of_recording)
        
        if audio_bytes is None:
            raise HTTPException(status_code=404, detail="Audio file not found in S3")
        
        # Create an async generator to stream the content
        async def stream_audio_content():
            yield audio_bytes
        
        # Set content type for M3U8 or MP3
        if recording_path.endswith(".m3u8"):
            content_type = "application/vnd.apple.mpegurl"
        elif recording_path.endswith(".mp3"):
            content_type = "audio/mpeg"
        else:
            raise HTTPException(status_code=400, detail="Unsupported file type")
        
        return StreamingResponse(
            stream_audio_content(),
            media_type=content_type
        )
    
    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in stream_audio: {e}")
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        logger.error(f"Error streaming audio: {e}")
        raise HTTPException(status_code=500, detail=f"Error streaming audio: {str(e)}")

@app.get("/api/call_details/{client}/{user_id}/{call_id}")
async def get_call_details(client: str, user_id: str, call_id: str, db: Session = Depends(get_database)):
    try:
        # Step 1: Verify Call ownership - FIXED: Updated join syntax
        call_record = (
            db.query(models.Call)
            .join(models.Model, models.Model.model_id == models.Call.model_id)
            .filter(
                models.Call.user_id == user_id,
                models.Call.call_id == call_id,
                models.Model.client_name == client.upper()
            )
            .first()
        )

        if not call_record:
            raise HTTPException(status_code=403, detail="Call does not belong to the user")

        transcription_val = await get_transcript(call_id, db)
        if transcription_val is None:
            return JSONResponse({
                "transcription": "Waiting for Transcription to be available. Please try again after the call is over.",
                'entity': "Waiting for Transcription to be available. Please try again after the call is over.",
                "conversation_eval": "Waiting for Transcription to be available. Please try again after the call is over.",
                "summary": "Waiting for Transcription to be available. Please try again after the call is over."
            })
        
        elif transcription_val['transcript'] in ['Error fetching transcript', 'Transcript not found in S3', "Transcript is empty"]:
            return JSONResponse({
                "transcription": "Transcript is not available for further evaluations.",
                'entity': "Transcript is not available for further evaluations.",
                "conversation_eval": "Transcript is not available for further evaluations.",
                "summary": "Transcript is not available for further evaluations."
            })

        transcription_ = transcription_val['transcript']

        # Check if summary exists in db, else generate it
        if client in regenerate_summaries:
            # We will regenerate the summary and then update the db.
            summary_ = await call_summary(transcription_)
            # Update summary in db
            if summary_.get("status_code") == 200:
                summary = summary_.get("summary")
                call_record.call_summary = summary
                db.commit()
            else:
                summary = "Error generating summary"
        else:
            # Check if summary already exists in db
            if call_record.call_summary:
                summary = call_record.call_summary
            else:
                summary_ = await call_summary(transcription_)
                print(f"summary_: {summary_}")
                # Update summary in db
                if summary_.get("status_code") == 200:
                    summary = summary_.get("summary")
                    call_record.call_summary = summary
                    db.commit()
                else:
                    summary = "Error generating summary"

        # Entity Extraction and conversation evaluation
        extractor_func = None
        field_list = None
        extractors_data = (extractors.get(client))
        if extractors_data:
            extractor_func = extractors_data.get("function")
            field_list = extractors_data.get("entities") if extractors_data.get("entities") is not None else None
        else:
            entity_extraction = "No extractor defined for this client"
            if client in need_conversation_eval:
                conversation_eva = call_record.call_conversation_quality if call_record.call_conversation_quality else {}
            else:
                conversation_eva = {}

            return JSONResponse({
                "transcription": transcription_,
                'entity': entity_extraction,
                "conversation_eval": conversation_eva,
                "summary": summary
            })
        
        if extractor_func is None:
            raise HTTPException(status_code=400, detail=f"No extractor defined for client: {client}")

        conversation_eva = None
        if client in skip_db_search:
            # We want to get everything in realtime and then send it to frontend
            entity_extraction = await extractor_func(
                transcript=transcription_,
                fields=field_list
            )
            if client in need_conversation_eval:
                conversation_eva = await conversation_eval(transcript=transcription_)
            else:
                conversation_eva = {}

            call_record.call_conversation_quality = conversation_eva
            call_record.call_entity = entity_extraction
            db.commit()
        else:
            if call_record.call_conversation_quality and call_record.call_entity:
                if client in need_conversation_eval:
                    conversation_eva = call_record.call_conversation_quality
                else:
                    conversation_eva = {}
                entity_extraction = call_record.call_entity
            else:
                if client in need_conversation_eval:
                    conversation_eva = await conversation_eval(transcript=transcription_)
                else:
                   conversation_eva = {} 
                   
                entity_extraction = await extractor_func(
                    transcript=transcription_,
                    fields=field_list
                )
                
                # Update the entry in db
                call_record.call_conversation_quality = conversation_eva
                call_record.call_entity = entity_extraction
                db.commit()

        return JSONResponse({
            "transcription": transcription_,
            'entity': entity_extraction,
            "conversation_eval": conversation_eva,
            "summary": summary
        })

    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in get_call_details: {e}")
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        logger.error(f"Error getting call details: {e}")
        raise HTTPException(status_code=500, detail=f"Error getting call details: {str(e)}")

#Model APIs
@app.post("/api/models/")
def create_model(model: ModelCreate, db: Session = Depends(get_database)):
    try:
        new_model = models.Model(**model.dict())
        db.add(new_model)
        db.commit()
        db.refresh(new_model)
        return new_model
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in create_model: {e}")
        db.rollback()
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        db.rollback()
        logger.error(f"Error creating model: {e}")
        raise HTTPException(status_code=500, detail=f"Error creating model: {str(e)}")

@app.get("/api/models/{client}")
def get_models(client: str, request: Request, db: Session = Depends(get_database)):
    try:
        print(client)
        models_list = db.query(models.Model).filter(models.Model.client_name == client.upper()).all()
        return models_list
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in get_models: {e}")
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        logger.error(f"Error getting models: {e}")
        raise HTTPException(status_code=500, detail=f"Error getting models: {str(e)}")

@app.put("/api/models/{model_id}")
def update_model(model_id: str, updated_model: ModelUpdate, db: Session = Depends(get_database)):
    try:
        db_model = db.query(models.Model).filter(models.Model.model_id == model_id).first()
        if not db_model:
            raise HTTPException(status_code=404, detail="Model not found")

        # Update only provided fields
        for key, value in updated_model.dict(exclude_unset=True).items():
            setattr(db_model, key, value)

        db.commit()
        db.refresh(db_model)
        return db_model
    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in update_model: {e}")
        db.rollback()
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        db.rollback()
        logger.error(f"Error updating model: {e}")
        raise HTTPException(status_code=500, detail=f"Error updating model: {str(e)}")

@app.post("/api/submit-feedback/")
def submit_feedback(feedback: FeedbackCreate, db: Session = Depends(get_database)):
    try:
        # FIXED: Map felt_natural to felt_neutral in the database
        feedback_data = feedback.dict()
        if 'felt_natural' in feedback_data:
            feedback_data['felt_neutral'] = feedback_data.pop('felt_natural')
        
        new_feedback = models.Feedback(**feedback_data)
        db.add(new_feedback)
        db.commit()
        return {"message": "Feedback submitted successfully"}
    except (OperationalError, DisconnectionError) as e:
        logger.warning(f"Database connection issue in submit_feedback: {e}")
        db.rollback()
        raise HTTPException(status_code=503, detail="Database connection issue, please try again")
    except Exception as e:
        db.rollback()
        logger.error(f"Error submitting feedback: {e}")
        raise HTTPException(status_code=500, detail=f"Error submitting feedback: {str(e)}")

#Health checks:
@app.get("/")
async def root():
    """Health check endpoint"""
    return {"status": "online", "service": "LiveKit Dispatch API"}

@app.get("/health")
async def health_check():
    """Enhanced health check endpoint that shows database configuration"""
    try:
        # Test database connection
        db = next(get_database())
        db.execute("SELECT 1")
        db_status = "connected"
        db.close()
    except Exception as e:
        db_status = f"error: {str(e)}"
    
    return {
        "status": "online", 
        "service": "LiveKit Dispatch API",
        "database_type": DB_TYPE,
        "database_status": db_status,
        "database_url_host": os.getenv("POSTGRES_URL", "sqlite:///.../backend/test.db").split('@')[1].split('/')[0] if DB_TYPE == "postgresql" and os.getenv("POSTGRES_URL") else "SQLite"
    }


if __name__ == "__main__":
    # Run the API with uvicorn
    uvicorn.run(app, host="0.0.0.0", port=1234)
    # get_database()


